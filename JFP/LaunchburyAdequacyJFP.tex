\documentclass{jfp1}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[safe]{tipa} % for \textlambda

\expandafter\let\csname equation*\endcsname\relax
\expandafter\let\csname endequation*\endcsname\relax
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage[amsmath,thmmarks]{ntheorem}
\usepackage{stmaryrd}
\usepackage{paralist}
\usepackage[pdfborder={0 0 0},naturalnames]{hyperref}
\usepackage{conteq}
\usepackage{microtype}
\newcommand{\myref}[2]{\hyperref[#2]{#1~\ref*{#2}}}

\allowdisplaybreaks[1]

\title[The Adequacy of Launchbury's Semantics]
      {The Adequacy of Launchbury's\\ Natural Semantics for Lazy Evaluation.}

 \author[J. Breitner]
        {JOACHIM BREITNER\thanks{supported by the Deutsche Telekom Stiftung}\\
	Programming Paradigms Group\\
         Karlsruhe Institute of Technology, Germany\\
         \email{breitner@kit.edu}}

\theorembodyfont{}
\newtheorem{theorem}{Theorem}
\newtheorem{falsetheorem}[theorem]{‘Theorem’}
\newtheorem{counterexample}[theorem]{Counter example}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}[lemma]{Corollary}

\expandafter\let\csname proof\endcsname\relax
\expandafter\let\csname proof*\endcsname\relax
\expandafter\let\csname endproof\endcsname\relax
\expandafter\let\csname endproof*\endcsname\relax
\theoremstyle{nonumberbreak}
\theoremheaderfont{\itshape}
\theoremsymbol{\proofbox}
%\theoremseparator{.}
\newtheorem{proof}{Proof}


\newcommand\pfun{\mathrel{\ooalign{\hfil$\mapstochar\mkern5mu$\hfil\cr$\to$\cr}}}

% Semantic sets
\newcommand{\sVar}   {\text{\textsf{Var}}}
\newcommand{\sExp}   {\text{\textsf{Exp}}}
\newcommand{\sHeap}  {\text{\textsf{Heap}}}
\newcommand{\sVal}   {\text{\textsf{Val}}}
\newcommand{\sValue} {\text{\textsf{Value}}}
\newcommand{\sCValue}{\text{\textsf{CValue}}}
\newcommand{\sEnv}   {\text{\textsf{Env}}}
\newcommand{\sC}     {\text{\textsf{C}}}

\newcommand{\sFn}[1]{\text{\textsf{Fn}}\,(#1)}
\newcommand{\sFnProj}[2]{#1\,\downarrow_{\text{\textsf{Fn}}}\,#2}
\newcommand{\sCFn}[1]{\text{\textsf{CFn}}\,(#1)}
\newcommand{\sCFnProj}[2]{#1\,\downarrow_{\text{\textsf{CFn}}}\,#2}

\newcommand{\req}[1]{=_{#1}}

% Syntax
\newcommand{\keyword}[1]{\text{\textsf{#1}}}
\newcommand{\sApp}[2]{#1\;#2}
\newcommand{\sLam}[2]{\text{\textlambda} #1.\, #2}
\newcommand{\sLet}[2]{\keyword{let}~#1~\keyword{in}~#2}

% Semantics
\newcommand{\sred}[5]{#1 : #2 \Downarrow_{#3} #4 : #5}
% 'DOWNWARDS TRIPLE ARROW' (U+290B)
\newcommand{\ssred}[4]{#1 : #2 \mathrel{\rotatebox[origin=c]{90}{$\Lleftarrow$}} #3 : #4}
\newcommand{\sRule}[1]{\text{{\textsc{#1}}}}

% Other functions and styles
\newcommand{\fv}[1]{\text{fv}(#1)}
\newcommand{\ufv}[1]{\text{ufv}(#1)}
\newcommand{\ur}[2]{\text{ur}_{#1}(#2)}
\newcommand{\dom}[1]{\text{dom}\;#1}
\newcommand{\fresh}[1]{#1'}
\newcommand{\xeng}{x_1 = e_1, \ldots, x_n = e_n}
\newcommand{\xen}{x_1\mapsto e_1, \ldots, x_n\mapsto e_n}

% Denotational semantics
\newcommand{\dsem}[2]{\llbracket #1 \rrbracket_{#2}}
\newcommand{\esem}[1]{\{\!\!\!\{#1\}\!\!\!\}}
\newcommand{\dsemr}[2]{\mathcal N\!\llbracket #1 \rrbracket_{#2}}
\newcommand{\esemr}[1]{\mathcal N\!\!\{\!\!\!\{#1\}\!\!\!\}}

\newcommand{\upd}[1]{\mathop{++_{#1}}}
\newcommand{\eqon}[1]{\mathrel{\mathord=_{\mathord|_{#1}}}}

\newcommand{\dsim}{\mathrel{\triangleleft\triangleright}}
\newcommand{\dsimheap}{\mathrel{\triangleleft\triangleright^*}}

\newcommand{\Crestr}[2]{ #1 |_{#2}}

% Text structuring
\newcommand{\case}[1]{\par\smallskip\noindent\textbf{Case:} #1\nopagebreak\par\noindent\ignorespaces}
\newcommand{\beginright}{&\mathrel{\phantom{=}}}
\newcommand{\aexpl}[1]{&\mathrel{\phantom{=}}\left\{\text{ #1 }\right\}}

\begin{document}

\label{firstpage}

\maketitle

\begin{abstract}
In his seminal paper “A Natural Semantics for Lazy Evaluation”, John Launchbury
proves his semantics correct with respect to a denotational semantics, and outlines a proof of adequacy.

Previous attempts to rigorize the adequacy proof, which involves an intermediate natural semantics and an intermediate resourced denotational semantics, have failed. We devised a new, direct proof that skips the intermediate natural semantics. It is the first rigorous adequacy proof of Launchbury’s semantics.

We have modelled our semantics in the interactive theorem prover Isabelle and machine-checked our proofs to obtain a maximum level of rigor. This was used in a machine-checked correctness proof of a compiler transformation.
\end{abstract}

% \tableofcontents

\section{Introduction}

The Natural Semantics for Lazy Evaluation created by Launchbury \shortcite{launchbury} has turned out to be a popular and successful base for theoretical treatment of lazy evaluation, especially as the basis of semantic extensions \cite{nakata, nakata_blackhole, distributed, mixed, parallel}. Therefore, its correctness and adequacy is important in this field of research. The original paper defines a standard denotational semantics to prove the natural semantics correct and adequate against.

Launchbury presents its correctness proof in sufficient detail, and it endures formal verification with only samll changes and clarifications (Sec.~TODO).

The adequacy proof in \cite{launchbury} is only an outline, though. It establishes the computational adequacy by two intermediate semantics:
\begin{compactitem}
\item A modified natural semantics with slightly different rules for variable lookup and function application that is more similar to how the denotational semantic works, and
\item a resourced denotational semantics, i.e.~one that keeps track of the number of steps required to evaluate an expression.
\end{compactitem}
The equivalence between the natural semantics and the alternative naural semantics was not proven by Launchbury. Although quite intuitive, a rigorous proof is yet to be found. S{\'a}nchez-Gil {\em et~al.} have attempted to perform this proof and obtained an equivalency proof for just the change to the application rule \shortcite{indirections}; the other half is still pending.

Having seen the difficulty of performing these proof steps on the side of the natural semantics, we departed from the outline provided by Launchbury and skipped the alternative natural semantics altogether. With a small, but important modification to the resourced denotational semantics, the proof was possible.

We have implemented and mechanically verified all definitions, propositions and proofs using the theorem prover Isabelle/HOL \cite{afp}. This way we can be confident that there are not holes left in the proof that would have to be filled by later generations. Furthermore it provides a tool that can be used in further work: In \cite{callartiy-icfp}, we use the denotational semantics to show the functional correctness of a compiler transformation, while we use the operational semantics to prove that the transformation does not degrade the program’s performance (measured in allocations).

%Therefore, we take the liberty to concentrate on the important steps and tricky calculations of the proofs here. In particular, we will not explicate the treatment of names, we implicitly expect heaps to be distinctly named and we do not show that partial operations like $\sqcup$ are defined where used. For all gory details, we refer the interested reader to the Isabelle proof document, which not only contains the full proofs, but also has the LaTeX code of the theorems automatically generated from the proved statements.

Our contributions are:
\begin{compactitem}
\item We reproduce and clarify Launchbury’s correctness proof (Sec.~TODO).
\item We analyze the alternative natural semantics used in his adequacy proof outline and show how to handle the differences on the denotational sides.
\item This way, we can provide a new and more direct proof of adequacy.
\item We provide an Isabelle implementation of the various definitions and a machine-checked proof.
\item We identify and discuss all adjustments to original definitions that we found to be required or helpful when rigorizing this work.
\end{compactitem}

\section{Launchbury's semantics}

Launchbury defines a semantics for a simple untyped lambda calculus consisting of variables, lambda abstraction, applications and mutually recursive bindings:
\begin{alignat*}{2}
x,y,z,w &\in \sVar
\displaybreak[1]
\\
e &\in
\sExp &&\Coloneqq
\sLam x e
\mid \sApp e x
\mid x \mid
\sLet {\xeng} e
\end{alignat*}

We equate alpha-equivalent lambda abstractions and \keyword{let} bindings, i.e.\ $\sLam x x = \sLam y y$ and $\fv{\sLam x {\sApp y x}} = \{y\}$, where $\fv e$ denotes the set of free variables of $e$. The theoretical foundation used is Nominal logic \cite{nominal}. This does impose a few well-formedness side conditions, such as equivariance of definition over expressions. We skip them in this presentation, and do so with good conscience, as they have been covered in the machine-checked proof.

Note that the term on the right hand side of an application has to be a variable. A general lambda term of the form $\sApp{e_1}{e_2}$ would have to be pre-processed to $\sLet{x = e_1}{\sApp{e_1}x}$ before it can be handled by this semantics.



\subsection{Natural semantics}

\begin{figure}
\begin{mathpar}
\inferrule
{ }
{\sred{\Gamma}{\sLam xe}L{\Gamma}{\sLam xe}}
\sRule{Lam}
\and
\inferrule
{\sred{\Gamma}e L{\Delta}{\sLam y e'}\\ \sred{\Delta}{e'[x/y]}L{\Theta}{v}}
{\sred\Gamma{\sApp e x}L\Theta v}
\sRule{App}
\and
\inferrule
{\sred\Gamma e {L\cup\{x\}}\Delta v}
{\sred{x \mapsto e,\Gamma} x L {x \mapsto v,\Delta}{v}}
\sRule{Var}
\and
\inferrule
{\dom\Delta \cap \fv{\Gamma,e,L} = \{\}\\   \sred{\Gamma,\Delta} e L \Theta v}
{\sred{\Gamma}{\sLet{\Delta}e} L \Theta v}
\sRule{Let}
\end{mathpar}
\caption{Launchbury natural semantics, as revised by Sestoft}
\label{fig_natsem}
\end{figure}

Launchbury gives this language meaning by a natural semantics, specified with the rules in Figure \ref{fig_natsem}, which obey the following naming convention for heaps and values:
\begin{alignat*}{2}
\Gamma, \Delta, \Theta &\in \sHeap &&= \sVar \pfun \sExp
\displaybreak[1]\\
v &\in \sVal &&\Coloneqq \sLam x e
\end{alignat*}

A heap is a partial function from variables to expressions; the same type is used for the list of bindings in a \keyword{let}. The domain of an heap $\Gamma$, written $\dom\Gamma$, is the set of variables bound in the heap.

A value is an expression in weak head normal form. A judgment of the form $\sred \Gamma e L \Delta v$ means that the expression $e$ with the heap $\Gamma$ reduces to $v$, while modifying the heap to $\Delta$.

The set $L$ was not present in Launchbury's rules, but added by Sestoft \shortcite{sestoft} to keep track of variables that must be avoided when choosing new names in the \sRule{Let} rule, but would otherwise not be present in the judgment any more.

We consider a judgment $\sred \Gamma L \Delta v$ to be \emph{closed} if $\fv{\Gamma, e} \subseteq \dom \Gamma \cup L$. Note that this property is preserved, as $\fv{\Delta, v} \subseteq \dom \Delta \cup L$ holds for closed judgments as well.

The evaluation does not drop bindings: $\sred \Gamma e L \Delta v$ implies $\dom \Gamma \subseteq \dom \Delta$.

\subsection{Denotational semantics}

In order to show that the natural semantics behaves as expected, Launchbury defines a standard denotational semantics for expressions and heaps, following Abramsky \shortcite{abramsky}. The semantic domain $\sValue$ is the initial solution to the domain equation
\[
\sValue = (\sValue \to \sValue)_\bot,
\]
which distinguishes $\bot$ from $\lambda x. \bot$. Lifting between $\sValue \to \sValue$ and $\sValue$ is performed using the injection $\sFn \_$ and projection $\sFnProj{\_}{\_}$. Values are partially ordered by~$\sqsubseteq$.

A semantic environment maps variables to values
\begin{alignat*}{2}
\rho \in \sEnv &= \sVar \to \sValue
\end{alignat*}
and the initial environment $\bot$ maps all variables to $\bot$. Environments are ordered by lifting the order on $\sValue$ pointwise.

The domain of an environment $\rho$, written $\dom\rho$, is the set of variables that are not mapped to $\bot$.
The environment $\rho|_S$, where $S$ is a set of variables, is the domain-restriction of $\rho$ to $S$:
\[
(\rho |_S)\, x = 
\begin{cases}
\rho\, x,& \text{if } x \in S\\
\bot& \text{if } x \not\in S.
\end{cases}
\]
The environment $\rho\setminus S$ is defined as the the domain-restriction of $\rho$ to the complement of $S$, i.e.\ \mbox{$\rho\setminus S \coloneqq \rho|_{\sVar \setminus S}$}.

The semantics of expressions and heaps are mutually recursive. The meaning of a expression $e \in \sExp$ in an environment $\rho \in \sEnv$ is written as $\dsem e \rho \in \sValue$ and is defined as
\begin{align*}
\dsem{\sLam x e}\rho &\coloneqq \sFn{\lambda v. \dsem e {\rho \sqcup \{x \mapsto v\}}}\\
\dsem{\sApp e  x}\rho &\coloneqq \sFnProj {\dsem e \rho}{\dsem x \rho}\\
\dsem{x}\rho &\coloneqq \rho\,x\\
\dsem{\sLet{\Delta}e}\rho &\coloneqq \dsem e {\esem{\Delta}\rho.}
\end{align*}

We can map this over a heap to obtain an envionment:
\begin{align*}
\dsem{\xen}\rho \coloneqq [x_1 \mapsto \dsem{e_1}{\rho}, \ldots, x_n \mapsto \dsem{e_n}{\rho}]
\end{align*}

The semantics of a heap $\Gamma \in \sHeap$ in an environment $\rho$, written $\esem \Gamma \rho \in \sEnv$, then obtained as a least  fixed-point:
\begin{align*}
\esem{\Gamma}\rho &= (\mu \rho'.\, \rho \upd{\dom \Gamma} \dsem{\Gamma}{\rho'})
\end{align*}
where
\[
(\rho \upd{S} \rho')~x \coloneqq
\begin{cases}
\rho~x, &\text{if } x \notin S \\
\rho'~x, &\text{if } x \in S.
\end{cases}
\]
is a restricted update operator.

The least fixed-point exists, as all involved operations are monotone and continuous.

We sometimes write $\esem{\Gamma}$ instead of $\esem{\Gamma}{\bot}$. In an expression $\esem{\Gamma}(\esem{\Delta}\rho)$ we omit the parentheses and write $\esem{\Gamma}\esem{\Delta}\rho$.


\subsection{Discussions of modifications}
\label{sec_modifications1}

It is rare that a formal system developed with pen and on paper can be formalized to the letter, partly because of vagueness (what, exacltly, is a ``completely'' fresh variable?), partly because of formalization convenience, and partly because the stated facts -- even if morally correct -- are wrong when read scrupulously. We discuss any such divergence from Launchbury's work here.

\subsubsection{Naming}

Getting the naming issues right is one of the major issues when formalizing anything involving bound variables. In Launchbury's work, the names are manifestly part of the syntax, i.e.\ $\sLam x x \ne \sLam y y$, and his rules involve explicit renaming of bound variables to fresh ones in the rule \sRule{Var}. His definition of freshness is a global one, so the validity of a derivation using \sRule{Var} depends on everything around it. This is morally what we want, but very unpractical.

Sestoft \shortcite{sestoft} noticed this problem and fixes it by adding a set $L$ of variables to the judgment, so that every variable to be avoided lives somewhere in $\Gamma$, $e$, or $L$. Instead of renaming all bound variables in the rule \sRule{Var}, he chooses fresh names for the new heap bindings in the \sRule{Let}.

We build on that, but go one step further and and completely avoid bound names in the expressions, i.e.\ $\sLam x x = \sLam y y$. We still have them in the syntax, of course, but these are just representatives of the same equivalency class. Nominal logic \cite{nominal}, which is implemented in Isabelle, forms the formal foundation for this. So in our rule \sRule{Let} we do not have to rename the variables, but simply may assume that the variables used in the representation of the \keyword{let}-expression are sufficiently fresh.

The names of bindings on the heap are not abstracted away in that manner; this follows \cite{nameless}.

\subsubsection{Closed judgments}

Launchbury deliberately allows non-closed configurations in his derivations, i.e.\ configurations with free variables in the terms that have no corresponding binding on the heap. This is a necessity, as rule \sRule{Var} models blackholing by removing a binding from the heap during its evaluation.

With the addition of the set of variables to avoid, which will always contain such varibles, the question can be revisited. And indeed, Sestoft defines the notion of \emph{$L$-good configurations}, where all free variables are either bound on the heap, or contained in $L$. He shows that this property is preserved by the operational semantics and subsequently considers only $L$-good configurations. We follow this example with our definition of \emph{closed} judgements. Threading the closedness requirement through an proof by rule induction is a typical chore contributing to the overhead of a machine-checked formalization.

\subsubsection{Join vs. update}

Launchbury specifies his denotational semantics using a binary operation $\sqcup$ on environments. He does not define it explicitly, but the statements in his Section 5.2.1 leave no doubt that he indeed intended this operation to denote the least upper bound of its arguments, as one would expect. Unfortunately, with this definition, his Theorem 2 (which corresponds to our \myref{Theorem}{thm_thm2}) is false. A counter example is $e = x$, $v = (\sLam{a}{\sLet{b = b}b})$, $\Gamma = \Delta = (x \mapsto v)$ and $\rho = (x \mapsto \sFn{\lambda \_. \sFn{\lambda x.x}})$ with the crucial property that $\rho$ contains compatible, but better information for a variable also bound in $\Gamma$. The mistake in his correctness proof is in the step $(\esem{x \mapsto v, \Delta}\rho)\,x = \dsem{v}{\esem{x \mapsto v, \Delta}\rho}$ in the case for \sRule{Var}, which should be $(\esem{x \mapsto v, \Delta}\rho)\,x = \dsem{v}{\esem{x \mapsto v, \Delta}\rho} \sqcup \rho\,x$.

Intuitively, such rogue $\rho$ are not relevant, and indeed they do not occur in the proof of the main \myref{Theorem}{thm_main}. Nevertheless, this issue needs to be fixed before attempting a formal proof. One possible fix is to replace $\sqcup$ by a right-sided update operation that just throws away information from the left argument for those variables bound on the right. We use the syntax $\rho \upd S \rho'$ for this operation, and by using that the proof goes through in full rigor.

It is slightly annoying having to specify the set $S$ in this operation explicitly, as it is usually clear ``from the context': Morally, it is the set of variables that the object on the right talks about. But as environments, i.e. total functions from $\sVar \to \sValue$, do not distinguish between variables not mentioned at all and variables mentioned, but bound to $\bot$, this information is not easily exploitable in a formal setting.

For the same reason we replace Launchbury’s ordering $\le$ on environments by the more explicit equality between restricted environments in the formulation of \myref{Theorem}{thm_thm2}.

\section{Correctness}

The main correctness theorem for the natural semantics is
\begin{theorem}[Correctness]
If $\sred \Gamma e L \Delta v$ holds and is closed, then $\dsem{e}{\esem{\Gamma}} = \dsem{v}{\esem{\Delta}}$.
\label{thm_main}
\end{theorem}

In order to prove this by rule induction, we have to generalize this to

\begin{theorem}[Correctness, generalized]
If $\sred \Gamma e L \Delta v$ holds and is closed, then for all environments $\rho \in \sEnv$ we have $\dsem{e}{\esem{\Gamma}{\rho}} = \dsem{v}{\esem{\Delta}{\rho}}$ and $(\esem\Gamma\rho)|_{\dom\Gamma} = (\esem\Delta\rho)|_{\dom\Gamma}$.%
\label{thm_thm2}
\end{theorem}

Our proof follows Launchbury's steps, but differs in some details.
%, the only differences are the use of $\preceq$ instead of $\le$ and the slightly different iterative fixed-point expression in case \sRule{Var}.
The required technical lemmas about the denotational semantics are compiled in appendix \ref{updsemanticsprops}.

For clarity, we write $\rho \eqon{S} \rho'$ for $\rho|_S = \rho'|_S$.

\begin{proof}
by induction on the derivation of $\sred \Gamma e L \Delta v$. Note that in such a derivation, all occuring judgments are closed.

\case{\sRule{Lam}}
This case is trivial.

\case{\sRule{App}}
By the induction hypothesis we know
$\dsem{e}{\esem{\Gamma}\rho} = \dsem{\sLam y {e'}}{\esem{\Delta}\rho}$ and $\esem{\Gamma}\rho  \eqon{\dom\Gamma} \esem{\Delta}\rho$ as well as $\dsem{e'[x/y]}{\esem{\Delta}\rho} = \dsem{v}{\esem{\Theta}\rho}$ and $\esem{\Delta}\rho \eqon{\dom\Delta} \esem{\Theta}\rho$.

We have $\esem{\Gamma}{\rho}~x = \esem{\Delta}{\rho}~x$: If $x\in \dom \Gamma$, this follows from the induction hypothesis. Otherwise, we know $x\in L$, as the judgment is closed, and the new names bound in $\Delta$ avoid $L$, so we have $\rho\, x$ on boths sides.

While the second part follows from the corresponding inductive hypotheses and $\dom\Gamma \subseteq \dom\Delta$, the first part is a simple calculation:
\begin{align*}
\dsem{\sApp{e}{x}}{\esem{\Gamma}\rho} &= \sFnProj{\dsem{e}{\esem{\Gamma}\rho}}{\dsem{x}{\esem{\Gamma}{\rho}}}\\
\aexpl{by the denotation of application} \\
&= \sFnProj{\dsem{\sLam y {e'}}{\esem{\Delta}\rho}}{\esem{\Gamma}{\rho}~x}\\
\aexpl{by the induction hypothesis} \\
&= \sFnProj{\dsem{\sLam y {e'}}{\esem{\Delta}\rho}}{{\esem{\Delta}{\rho}}~x}\\
\aexpl{see above} \\
&= \dsem{e'}{(\esem{\Delta}\rho)(y \mapsto {\esem{\Delta}{\rho}}~x)}\\
\aexpl{by the denotation of lambda abstraction} \\
&= \dsem{e'[x/y]}{\esem{\Delta}\rho}\\
\aexpl{by \myref{Lemma}{lem_subst}} \\
&= \dsem{v}{\esem{\Theta}\rho}\\
\aexpl{by the induction hypothesis}
\end{align*}

\case{\sRule{Var}}
We know that $\dsem{e}{\esem{\Gamma}\rho'}=\dsem{v}{\esem{\Delta}\rho'}$ and $\esem{\Gamma}{\rho'} \eqon{\dom\Gamma} \esem{\Delta}{\rho'}$ for all $\rho'\in\sEnv$.

We begin with the second part:
\begin{align*}
\esem{x \mapsto e,\Gamma}{\rho}
&= \mu \rho'.\,(\rho \upd{\dom\Gamma} \esem{\Gamma}{\rho'})[x \mapsto \dsem{e}{\esem{\Gamma}\rho'}] \\
\aexpl{by Lemma \ref{lem_iter}} \\
&= \mu \rho'.\,(\rho \upd{\dom\Gamma} \esem{\Gamma}{\rho'})[x \mapsto \dsem{z}{\esem{\Delta}\rho'}] \\
%\aexpl{by the induction hypothesis, invoked for $\rho'$!} \\
\aexpl{\parbox{\widthof{by the induction hypothesis. Note that}}{\raggedright by the induction hypothesis. Note that we invoke it for $\rho'$ with $\rho' \ne \rho$!}} \\
&\eqon{\dom{(x \mapsto e,\Gamma})}
\mu \rho'.\,(\rho \upd{\dom\Delta} \esem{\Delta}{\rho'})[x \mapsto \dsem{z}{\esem{\Delta}\rho'}] \\
\aexpl{by the induction hypothesis; see below} \\
&= \esem{x \mapsto v, \Delta}{\rho}\\
\aexpl{by Lemma \ref{lem_iter}}
\end{align*}

The second but last step is quite technically, as we need to push the $|_{\dom{(x \mapsto e,\Gamma})}$ inside the fixed-point operator. This goes through by parallel fixed-point induction if we first generalize it to $|_{\sVar \setminus \dom\Delta \mathop\cup \dom{(x \mapsto e,\Gamma)}}$, the complement of the new variables added to the heap during evaluation of $x$.

The first part now follows from the second part:
\begin{align*}
\dsem{x}{\esem{x \mapsto e, \Gamma}\rho} &=
(\esem{x \mapsto e, \Gamma}\rho)\,x &
%\aexpl{by the denotation of variables}
\\
&= (\esem{x \mapsto v, \Delta}\rho)\,x &
\aexpl{by the first part and $x\in\dom(x \mapsto e,\Gamma)$} \\
&= \dsem{v}{\esem{x \mapsto v, \Delta}\rho}
& \aexpl{by the \myref{Lemma}{lem_esem_this}.}
\end{align*}

\case{\sRule{Let}}
We know that $\dsem{e}{\esem{\Gamma, \Delta}\rho} = \dsem{v}{\esem{\Theta}{\rho}}$ and $\esem{\Gamma, \Delta}\rho \eqon{\dom{(\Gamma, \Delta)}} \esem{\Theta}{\rho}$.
For the first part we have
\begin{align*}
\dsem{\sLet{\Delta}e}{\esem{\Gamma}\rho}
&= \dsem{e}{\esem{\Delta}{\esem{\Gamma}\rho}} &
\aexpl{by the denotation of let-expressions} \\
&= \dsem{e}{\esem{\Gamma, \Delta}{\rho}} &
\aexpl{by Lemma \ref{lem_esem-merge}} \\
&= \dsem{v}{\esem{\Theta}{\rho}} &
\aexpl{by the induction hypothesis}
\intertext{and for the second part we have}
\esem{\Gamma}{\rho} 
&\eqon{\dom\Gamma} \esem{\Delta}{\esem{\Gamma}\rho} &
\aexpl{because $\dom\Delta$ are fresh} \\
&= \esem{\Gamma, \Delta}\rho &
\aexpl{by Lemma \ref{lem_esem-merge}} \\
&\eqon{\dom{(\Gamma,\Delta)}} \esem{\Theta}\rho. &
\aexpl{by the induction hypothesis.}
\end{align*}
\end{proof}

\subsection{Discussions of modifications}
\label{sec_modifications2}

Our main \myref{Theorem}{thm_main} and the generalization in \myref{Theorem}{thm_thm2} differ from Launchbury's corresponding Theorem 2. The additional requirement that the judgements are closed is discussed in Section \ref{sec_modifications1}.

Furthermore, the second part of the \myref{Theorem}{thm_thm2} is phrased differently. Launchbury states  $\esem\Gamma\rho \le \esem\Delta\rho$ where $\rho \le \rho'$ is defined as $(\forall x.\, \rho\,x \ne \bot \implies \rho x = \rho' x)$, i.e. $\rho'$ agrees with $\rho$ on all variables that have a meaning in $\rho$.

The issue with this definition is that there are two reasons why $\esem\Gamma\rho\,x=\bot$ can hold: Either $x \notin \dom\Gamma$, or $x \in \dom\Gamma$, but bound to a diverging value. Only the first case is intended here, and actually $\le$ is used as if only that case can happen, e.g.\ in the case for \sRule{Var} in the correctness proof. We therefore avoid the problematic $\le$ relation and explicitly show  $\esem\Gamma\rho \eqon{\dom\Gamma}  \esem\Delta\rho$.


\section{Adequacy}

A correctness theorem for a natural semantics is not worth much on its own. Imagine a mistake in side condition of the \sRule{Let} rule that accidentially prevents any judgment to be derived for programs with a \keyword{let} -- the correctness theorem would still hold.

So we want to ensure that all programs that have a meaning, in our case according to the denotational semantics, also have a derivation:

\begin{theorem}[Adequacy]
For all $e$, $\Gamma$ and $L$, if $\dsem{e}{\esem{\Gamma}} \ne \bot$, then there exists $\Delta$ and $v$ so that $\sred \Gamma e L \Delta v$.
\label{thm_adequacy}
\end{theorem}

The proof uses a modified denotational semantics that keeps track of the number of steps required to determine the non-bottomness of $e$, which we will now introduce, prove adequate and show its relationship to the standard denotational semantics.

\subsection{The resourced denotational semantics}

The domain used to count the resources is a solution to the equation $\sC = \sC_\bot$. The lifting is done by the injection function $C \colon \sC \to \sC$, so the elements are $\bot \sqsubset C~\bot \sqsubset C~(C~\bot) \sqsubset \cdots \sqsubset C^\infty$ – this is isomorphic to the extended naturals. We use $r$ for variables ranging over $\sC$.


The resourced semantics $\dsemr{e}{\rho}~r$ now takes an additional argument $r \in \sC$ which indicates the number of steps the semantics is still allowed to perform: Every rescursive call in the definition of $\dsemr{e}{\rho}~r$ peels of one application of $C$ until none are left.

The intuition is that if we pass in an infinite number of resources, the two semantics coincide: \[
\forall x.\, \rho~x = \sigma~x~C^\infty \implies \dsem{e}{\rho} = \dsemr{e}{\sigma}~C^\infty,
\]
as Launchbury puts it. While the intuition is true, it cannot be stated that naively: Because the semantics of an expression is now a function taking a $\sC$, this needs to be reflected in the domain equation, so we obtain a different domain, as observed by S{\'a}nchez-Gil {\em et~al.} \shortcite{functionspaces}:
\[
\sCValue = ((\sC \to \sCValue) \to (\sC \to \sCValue))_\bot,
\]
The lifting and the projection functions are hence
\begin{align*}
\sCFn \_ &\colon (\sC \to \sCValue) \to (\sC \to \sCValue) \to \sCValue \\
\sCFnProj{\_}{\_} &\colon \sCValue \to (\sC\to\sCValue) \to (\sC \to \sCValue).
\end{align*}
We use $\sigma$ for variables ranging over resourced envrionments, $\sigma \in \sVar \to (\sC \to \sCValue)$.


The definition of the resourced semantics resembles the definition of the standard semantics, with some resource bookkeeping added:
\begin{align*}
\dsemr{e}\sigma~ \bot &\coloneqq \bot\\
\dsemr{\sLam x e}\sigma ~ (C~r) &\coloneqq \sCFn{\lambda v. \Crestr{\dsemr e {\sigma \sqcup \{x \mapsto v\}}} r}\\
\dsemr{\sApp e  x}\sigma ~ (C~r) &\coloneqq (\sCFnProj {(\dsemr e \sigma~r)}{\Crestr{(\sigma~x)} r})~r\\
\dsemr{x}\sigma ~ (C~r) &\coloneqq \sigma~x~r\\
\dsemr{\sLet{\Delta}e}\sigma ~ (C~r) &\coloneqq \dsemr e {\esem{\Delta}\sigma}~r
\end{align*}
where $\Crestr{f}{r}$ restricts a function $f$ with domain $C$ to take at most $r$ resources: $\Crestr f r \coloneqq (\lambda r'.\, f ~(r \sqcap r'))$.

The semantics of the heap is defined as before:
\begin{align*}
\esemr{\Gamma}\sigma &\coloneqq (\mu \sigma'.\, \sigma \upd{\dom \Gamma} \dsemr{\Gamma}{\sigma'}).
\end{align*}

Given the similarity between this semantics and the standard semantics, it is not surprising that an analogous correctness lemma holds:

\begin{lemma}[Correctness, resourced]
If $\sred \Gamma e \Delta v$ holds and is closed, then for all environments $\sigma$ we have $\dsemr{e}{\esem{\Gamma}{\sigma}} \sqsubseteq \dsemr{v}{\esem{\Delta}{\sigma}}$ and $(\esemr\Gamma\sigma)|_{\dom\Gamma} \sqsubseteq (\esemr\Delta\sigma)|_{\dom\Gamma}$.%
\label{lem_resourced_correctness}
\end{lemma}

\begin{proof}
Analogously to the proof of \autoref{thm_thm2}.
\end{proof}

\subsection{Denotational black holes}
\label{sec_denblackhole}

The major difficulty in proving computational adequacy was the the blackholing behaviour of the operational semantics: During the evaluation of a variable $x$ the corresponding binding is removed from the heap. Operationally, this is desirable: If the variable is called again during its own evaluation, we have an infinite loop.

But obviously, the variable is still mentioned in the current configuration, and simply removing the binding will change the denotation of the configuration in unwanted ways: There is no hope of proving $\dsemr{e}{\esemr{x\mapsto e, \Gamma}} = \dsemr{e}{\esemr{\Gamma}}$.

But we can prove a weaker statement, which reflects the idea of ``not using $x$ during its own evaluation'' more closely:

\begin{lemma}[Denotational blackholing]
\label{lem_denblackhole}
\[
\dsemr{e}{\esemr{x\mapsto e, \Gamma}} r \ne \bot \implies \dsemr{e}{\esemr{\Gamma}} r \ne \bot
\]
\end{lemma}

This is a consequence of the following lemma, which states that during the evaluation of an expression using finite resources, the only fewer resources will be passed to the members of the environment (which are of type $\sC \to \sCValue$):

\begin{lemma}
\[
\label{lem_denrestr}
\Crestr{\dsemr{e}\sigma}{C~r} = \Crestr{\dsemr{e}{(\Crestr{\sigma}{r})}}{C~r}
\]
\end{lemma}
\begin{proof}
by induction on the expression $e$.


In order to show $\Crestr{\dsemr{e}\sigma}{C~r} = \Crestr{\dsemr{e}{(\Crestr{\sigma}{r})}}{C~r}$ it suffices to show $\dsemr{e}\sigma~(C~r') = \dsemr{e}{(\Crestr{\sigma}{r})}~(C~r)$ for an arbitrary $r'\sqsubseteq r$.

The critical case is the one for variables, where $e = x$. We have
\begin{conteq}[oneline]
\dsemr{x}\sigma~(C~r')
\\
= \sigma~x~r' \\
= (\Crestr{\sigma~x}{r})~r' & as $r'\sqsubseteq r$ \\
= \dsemr{x}{(\Crestr{\sigma}{r})}~(C~r')
\end{conteq}
as $r'\sqsubseteq r$.

In the other cases, the result follows from the fact that nested expressions are evaluated with $r'$ resources or, in the case of lambda abstraction, wrapped inside a $\Crestr \strut {r'}$ restriction operator.

For the case of \keyword{let}, a related lemma for heaps needs to be proven by parallel fixed-point induction, namely $\forall r.\, \Crestr{(\esemr{\Gamma}\sigma)}r = \Crestr{(\esemr{\Gamma}{(\Crestr\sigma r)})}r$.
\end{proof}

Equipped with this lemma, we can begin the

\begin{proof}[of \myref{Lemma}{lem_denblackhole}]
Let $r'$ be the least resource such that $\dsemr{e}{\esemr{x\mapsto e, \Gamma}} (C~r') \ne \bot $. Such an $r'$ exists by the assumption, and $C~r' \sqsubseteq r$, and is, by the continuity of the semantics, not $C^\infty$. In particular, $\dsemr{e}{\esemr{x\mapsto e, \Gamma}} r' = \bot$.

We first show
\begin{equation}
\Crestr{\esemr{x\mapsto e, \Gamma}}{r'} \sqsubseteq \esemr{\Gamma} \tag{$\ast$}
\end{equation}
by bounded fixed-point induction. So given an arbitrary $\sigma \sqsubseteq \esemr{x\mapsto e, \Gamma}$, we may assume $\Crestr{\sigma}{r'} \sqsubseteq \esemr{\Gamma}$ and have to prove $\Crestr{\dsemr{x\mapsto e, \Gamma}{\sigma}}{r'} \sqsubseteq \esemr{\Gamma}$, which we do point-wise:

For $y\mapsto e'\in\Gamma$, this follows from
\begin{conteq}
\Crestr{\dsemr{x\mapsto e, \Gamma}{\sigma}}{r'}~y \\
= \Crestr{\dsemr{e'}{\sigma}}{r'}  \\
= \Crestr{\dsemr{e'}{\Crestr{\sigma}{r'}}}{r'} & by \myref{Lemma}{lem_denrestr} \\
\sqsubseteq \dsemr{e'}{\Crestr{\sigma}{r'}} \\
\sqsubseteq \dsemr{e'}{\esemr{\Gamma}} & by the induction hypothesis  \\
= \esemr{\Gamma}~y & by \myref{Lemma}{lem_esem_this}
\end{conteq}
while for $x$, this follows from
\begin{conteq}
\Crestr{\dsemr{x\mapsto e, \Gamma}{\sigma}}{r'}~x \\
= \Crestr{\dsemr{e}{\sigma}}{r'} \\
\sqsubseteq \Crestr{\dsemr{e}{\esemr{x\mapsto e, \Gamma}}}{r'} & using $\sigma \sqsubseteq \esemr{x\mapsto e, \Gamma}$ \\
= \bot & by the choice of $r'$ \\
= \esemr{\Gamma}~x & as $x \notin \dom\Gamma$.
\end{conteq}

\noindent So we can conclude the proof with
\begin{conteq}
\bot \\
\sqsubset \dsemr{e}{\esemr{x\mapsto e, \Gamma}} (C~r') & by the choice of $r'$ \\
= \dsemr{e}{\Crestr{\esemr{x\mapsto e, \Gamma}}{r'}} (C~r') & by \myref{Lemma}{lem_denrestr} \\
\sqsubseteq \dsemr{e}{\esemr{\Gamma}} (C~r')  & by $(\ast)$  \\
\sqsubseteq \dsemr{e}{\esemr{\Gamma}} r & as $C~r'\sqsubseteq r$
\end{conteq}
\end{proof}

\subsection{Resourced adequacy}

With the necessary tools in place to handle blackholing, we can do the adequacy proof for the resourced semantics:

\begin{lemma}[Resourced semantics adequacy]
\label{lem_resad}
For all $e$, $\Gamma$ and $L$,  if $\dsemr{e}{\esem{\Gamma}}~r \ne \bot$, then there exists $\Delta$ and $v$ so that $\sred \Gamma e L \Delta v$.
\end{lemma}

\begin{proof}
Because the semantics is continuous, it suffices to show this for $r = C^n~\bot$, and perform induction on this $n$, with arbitrary $e$, $\Gamma$ and $L$.

The case $r=C^0~\bot = \bot$ is vacuously true, as $\dsemr{e}{\esem{\Gamma}}~\bot = \bot$.

For the inductive case assume that the lemma holds for $r$, and that $\dsemr{e}{\esem{\Gamma}}~(C~r) \ne \bot$. We proceed by case analysis on the expression $e$.

\case{$e = x$.}
From the assumption we know that $\Gamma = x\mapsto e',\Gamma'$ for some $e'$ and $\Gamma'$, as otherwise the denotation would be bottom, and furthermore that $\dsemr{e'}{\esemr{x\mapsto e',\Gamma'}}~r \ne\bot$

With \myref{Lemma}{lem_denblackhole} this implies $\dsemr{e'}{\esemr{\Gamma'}}~r \ne\bot$, so we can apply the induction hypothesis and obtain $\Delta$ and $v$ with $\sred {\Gamma'} {e'} {L\cup\{x\}} \Delta v$. This implies $\sred {x\mapsto e',\Gamma'} {x} {L} \Delta v$ by rule \sRule{Var}, as desired.

\case{$e = e'~x$.}
Assume that $\fv{\Gamma, e'} \subseteq L$. We do not lose generality here: If we can show a derivation in the natural semantics with a larger set of variables to avoid than required, then the same derivation is also valid with the required set $L$.

From the assumption we know that
$\sCFnProj {(\dsemr {e'} {\esemr{\Gamma}}~r}{\Crestr{({\esemr{\Gamma}}~x)}{r}})~r \ne \bot$. In particular $(\dsemr {e'} {\esemr{\Gamma}}~r)\ne \bot$, so by the induction hypothesis we have $\Delta$, $y$ and $e''$ with $\sred{\Gamma}{e'}L\Delta {\sLam y {e''}}$, the first hypothesis of \sRule{App}.

This judgment is closed by our extra assumption, so we use \myref{Lemma}{lem_resourced_correctness} to ensure that $\dsemr{e'}{\esemr{\Gamma}} \sqsubseteq \dsemr{\sLam y {e''}}{\esemr{\Delta}}$ and $\esemr{\Gamma} \sqsubseteq \esemr{\Delta}$. We can insert that into the inequality above to calculate
\begin{conteq}
\bot \\
\sqsubset \sCFnProj {(\dsemr {e'} {\esemr{\Gamma}}~r}{\Crestr{({\esemr{\Gamma}}~x)}{r}})~r \\
\sqsubseteq (\sCFnProj {\dsemr {\sLam y {e''}} {\esemr{\Delta}}~r                               }{\Crestr{({\esemr{\Delta}}~x)}{r}})~r \\
\sqsubseteq (\sCFnProj {\dsemr {\sLam y {e''}} {\esemr{\Delta}}~r                               }{\esemr{\Delta}~x})~r \\
\sqsubseteq (\sCFnProj {\sCFn{\lambda v.\, \dsemr {e''} {\esemr{\Delta} \sqcup \{y \mapsto v\}}}}{\esemr{\Delta}~x})~r \\
= \dsemr {e''} {\esemr{\Delta} \sqcup \{y \mapsto (\esemr{\Delta}~x)\}}~r \\
= \dsemr {e''[x/y]} {\esemr{\Delta} }~r  & by \myref{Lemma}{lem_subst}
\end{conteq}
which, using the induction hypothesis again, provides us with $\Theta$ and $v$ so that the second hypothesis of \sRule{App}, $\sred{\Delta}{e''[x/y]}L\Theta v$, holds, concluding this case.

\case{$e=\sLam y {e'}$}
This case follows immediately from rule \sRule{Lam} with $\Delta=\Gamma$ and $v = \sLam y{e'}$.

\case{$e=\sLet \Delta {e'}$}
We have
\begin{conteq}
\bot \\
\sqsubset \dsemr{\sLet \Delta {e'}}{\esemr{\Gamma}}~r \\
\sqsubseteq \dsemr{e'}{\esemr{\Delta}{\esemr{\Gamma}}} \\
= \dsemr{e'}{\esemr{\Delta,\Gamma}} & by \myref{Lemma}{lem_esem-merge}
\end{conteq}
so we have $\Theta$ and $v$ with $\sred{\Delta,\Gamma}{e'}L\Theta v$ and hence$\sred{\Gamma}{\sLet \Delta {e'}}L\Theta v$ by rule \sRule{Let}, as desired.
\end{proof}


\subsection{Relating the denotational semantics}

\myref{Lemma}{lem_resad} is almost what we want, but it talks about the resourced denotational semantics. In order to obtain that result for the standard denotational semantics, we need to relate these two semantics. We cannot simply equate them, as they have different denotational domains $\sValue$ and $\sC\to\sCValue$. So we are looking for a relation $\dsim$ between $\sValue$ and $\sCValue$ that expresses the intuition that they behave the same, if the latter is given infinite resources. In particular, it is specified by the two equations
\[
\bot \dsim \bot
\]
and
\[
(\forall x\,y.\, x \dsim y~C^\infty \implies f~ x \dsim g~y~C^\infty)
\iff \sFn f \dsim \sCFn g.
\]

Unfortunately, this is not admissible as an inductive definition, as it is self-referential in a non-monotone way, so the construction of this relation is non-trivial. This was observed and performed by S{\'a}nchez-Gil {\em et~al.} \shortcite{functionspaces}, and we have subsequently implemented this construction in Isabelle.

We lift this relation to envrionments $\rho \in \sEnv$ and resourced envrionments $\sigma \in \sVar \to (\sC \to \sValue)$ by
\[
\rho \dsimheap \sigma \iff \forall x.\, \rho~x \dsim \sigma~x~C^\infty.
\]

This allows us to state precisely how the two denotational semantics are related:

\begin{lemma}[The denotational semantics are related]
\label{lem_denrel}
For all environments $\rho \in \sEnv$ and $\sigma \in \sVar \to (\sC \to \sValue)$ with $\rho \dsimheap \sigma$, we have
\[
\dsem e \rho \dsim \dsemr e \sigma~{C^\infty}.
\]
\end{lemma}

\begin{proof}
Intuitively, the proof is obvious: As we are only concerned with infinite resources, all the resource counting added to the denotational semantics becomes moot and the semantics are obviously related. A more rigorous proof can be found in \cite{functionspaces} and in our formal verification.
\end{proof}

\begin{corollary}
For all heaps $\Gamma$, we have $\esem{\Gamma}\dsimheap \esemr{\Gamma}$.
\label{lem_denrelheap}
\end{corollary}

\begin{proof}
by parallel fixed-point induction and \myref{Lemma}{lem_denrel}.
\end{proof}

\subsection{Concluding the adequacy}

With this in place, we can give the
\begin{proof}[of \myref{Theorem}{thm_adequacy}]
By \myref{Corollary}{lem_denrelheap} we have $\esem{\Gamma}\dsimheap \esemr{\Gamma}$, and with \myref{Lemma}{lem_denrel} this implies $\dsem{e}{\esem{\Gamma}} \dsim \dsemr{e}{\esemr{\Gamma}}~C^\infty$.

With our assumption $\dsem{e}{\esem{\Gamma}} \ne \bot$ and the definition of $\dsim$ this ensures that $\dsemr{e}{\esem{\Gamma}}~C^\infty \ne \bot$, and we can apply \myref{Lemma}{lem_resad}, as desired.
\end{proof}


\subsection{Discussions of modifications}
\label{sec_modifications3}

Our adequacy proof diverges quite a bit from Launchbury's. As this new proof constitutes a major part of this paper's contribution, we discuss the differences in greater detail.

\begin{figure}
\begin{mathpar}
\inferrule
{\sred{\Gamma}e L{\Delta}{\sLam y e'}\\ \sred{y\mapsto x, \Delta}{e'}L{\Theta}{v}}
{\sred\Gamma{\sApp e x}L\Theta v}
\sRule{App'}
\and
\inferrule
{\sred{x\mapsto e, \Gamma} e L \Delta v}
{\sred{x\mapsto e, \Gamma} x L \Delta v}
\sRule{Var'}
\end{mathpar}
\caption{Launchbury alternative natural semantics}
\label{fig_natsem}
\end{figure}

Launchbury performs the adequacy proof by introducing an alternative natural semantics (ANS) that is closer to the denotational semantics than the original natural semantics (NS). He replaces the rules \sRule{App} and \sRule{Var} by the two rules given in \myref{Figure}{fig_ans}. There are three differences to be spotted:
\begin{enumerate}
\item In the rule for applications, instead of substituting the argument $x$ for the parameter $y$, the variable $y$ is added to the heap, bound to $x$, adding an \emph{indirection}.
\item In in the rule for variables, no update is performend: Even after $x$ has been evaluated to the value $v$, the binding $x$ on the heap is not modified at all.
\item Also in the rule for variables, no black-holing is performed: The binding for $x$ stays on the heap during its evaluation.
\end{enumerate}

Without much ado, Launchbury states that the original natural semantics and the alternative natural semantics are equivalent, which is intuitively obvoius. Unfortunately, it turned out that a rigorous proof of this fact is highly non-trivial, as the actual structure of the heaps during evaluation differs a lot: The modification to the application rule causes many indirections, which need to be taken care of. Furthermore, the lack of updates in the variable rules causes possibly complex, allocating expressions to be evaluated many times, each time adding further copies of already existing expressions to the heap. On the other side, the updates in the original semantics further obscure the relationship between the heaps in the original and the alternative semantics. On top of all that add the technical difficulty that is due to naming issues: Variables that are fresh in one derivation might not be fresh in the other, and explicit renamings need to be carried along.

S{\'a}nchez-Gil {\em et~al.} have attempted to perform this proof. They broke it down into individual steps, going from the original semantics to one with only the variable rule changes (called No-update natural semantics, NNS), and from there to the ANS. So far, they have performed the second step, the equivalence between NNS and ANS, in a pen-and-paper proof (\shortcite{indirections}), while relation between NS and NNS has yet resited a proper proof.

Considering these difficulties, we attempt to go a different path, and bridge the differences not on the side of the natural semantics, but on the denotational side, which turned out to work well:

\begin{enumerate}
\item The denotational semantics for lambda expressions involves a change to the environment ($\dsem{\sLam x e}\rho \coloneqq \sFn{\lambda v. \dsem e {\rho \sqcup \{x \mapsto v\}}}$), while the natural semantics uses substitution into the expression: $e[x/y]$.

This difference is easily bridged on the denotational side by a standard substitution \myref{Lemma}{lem_subst}, which is needed anyways for the correctness proof. See the last line of the application case in the proof of \myref{Lemma}{lem_resad} for this step.

\item The removal of updates had surprisingly no effect on the adequacy proof: The main chore of the adequacy proof is to produce evidence for the \emph{assumptions} of the corresponding natural semantics inference rule, which is then, in the last step, applied to produce the desired judgment. The removal of updates only changes the \emph{conclusion} of the rule, so the adequacy proof is unchanged.

Of course updates are not completely irrelevant, and they do affect the adequacy proof indirectly. The adequacy proof uses a correctness theorem for the resourced natural semantics, and there the removal of updates from the semantics would make a noticable difference.

\item Finally, and most trickily, there is the issue of blackholing. We explain our solution in \myref{Section}{sec_denblackhole}, which works due to a small modification to the resourced denotational semantics.

Our proof relies on the property that when we calculate the semantics of $\dsemr{e}\sigma\,r$, we never pass more than $r$ resources to the values bound in $\sigma$ (\myref{Lemma}{lem_denrestr}). This concurs with our intuition about resources.

In the original definition of the resurced semantics, this lemma does not hold: The equation for lambda expression ignores the resources passed to it and returns a function involving the semantics of the body:
\[
\dsemr{\sLam x e}\sigma ~ (C~r) = \sCFn{\lambda v. \dsemr e {\sigma \sqcup \{x \mapsto v\}}}
\]
With that definition, $\dsemr{\sLam x y}\sigma~(C~\bot) = \sCFn{\sigma~y}$, which depends on $\sigma~y~r$ for all $r$, contradicting \myref{Lemma}{lem_denrestr}.

Therefore we restrict the function wrapped in $\sCFn \_$ to cap any resources passed to it at $r$. Analogously we adjust the equation for applications to cap any resources passed to the value of the argument in the enrivonment, $\sigma~x$.

These modifications do not affect the proof relating the two denotational semantics (\myref{Lemma}{lem_denrel}), as there we always pass infinite resources, and $|_{C^\infty}$ is the identity function.

\end{enumerate}

\section{Related work}

A large number of developments on formal semantics of functional programming languages in the last two decades build on Launchbury’s work. Many of them implicitly or explicitly rely on the correctness proof as spelled out by Launchbury:

Van Eekelen \& de~Mol \shortcite{mixed} add strictness annotations to the syntax and semantics of Launchbury’s work. They state the correctness as in `Theorem' \ref{thm_false}, without spotting the issue.


Nakata \& Hasegawa \shortcite{nakata} define a small-step semantics for call-by-need and relate it to a Launchbury-derived big-step semantics. They state the correctness with respect to the denotational semantics and reproduce the `Theorem' \ref{thm_false} in the flawed form, in their extended version.

S{\'a}nchez-Gil {\em et~al.} \shortcite{distributed} extend Launchbury's semantics with distributed evaluation.  In their modified natural semantics the heap retains the expression under evaluation with a special flag, marking them as blocked. Furthermore, the expression under evaluation has a name. Thus the non-distributed subset of their semantics is very similar to our stacked semantics and their correctness statement corresponds to Theorem \ref{thm_thm2}.

An interesting case is the work by Baker-Finch {\em et~al.} on parallel call-by-need: While an earlier report \shortcite{parallel-tr} uses Launchbury’s definitions unmodified and states the flawed `Theorem' \ref{thm_false}, the following publication at ICFP \shortcite{parallel} uses an update-based denotational semantics, unfortunately without motivating that change.

Similarly, Nakata  \shortcite{nakata_blackhole}, who modifies the denotational semantics to distinguish direct cycles from looping recursion, uses update-based semantics without further explanation. 

This list is just a small collection of many more Launchbury-like semantics. Often the relation to a denotational semantics is not stated, but nevertheless they are standing on the foundations laid by Launchbury. Therefore it is not surprising that others have worked on formally fortifying these foundations as well:

S{\'a}nchez-Gil {\em et~al.} identified a step in his adequacy proof relating the standard and the resourced denotational semantics that is not as trivial as it seemed at first and worked out a detailed pen-and-paper proof \shortcite{functionspaces}. They also plan to prove the equivalency between Launchbury’s natural semantics and a variant thereof, which was used by Launchbury in his adequacy proof, in the theorem prover Coq. As one step in that direction, they address the naming issues and suggest a mixed representation, using de Bruijn indices for locally bound variables and names for free variables \shortcite{nameless}. This corresponds to our treatment of names in the formal development, using the Nominal logic machinery \cite{nominal} locally but not for names bound in heaps.

\section{Discussion}

Although we have found a flaw in the proof and the formulation of the correctness theorem in Launchbury’s semantics, the essential correctness result (as formulated in Theorem~\ref{thm_main}) stills holds. In that sense our work, especially with the computer-verified proofs in \cite{afp}, actually strengthens the foundations of formal work in that field.

We have provided two ways to fix the problem: One by adding a stack to the operational semantics, and one by changing the denotation of heaps. Both variants have precursors in the literature: The extended heaps of \cite{distributed} resemble the heap-stack-pairs of our semantics, while Baker-Finch {\em et~al.} \shortcite{parallel} and Nakata \shortcite{nakata_blackhole} use right-sided updates in their denotational heap semantics.

Adding the stack to the judgments of the natural semantics, although it does not affect the evaluation of expressions at all, seems to make the semantics more suitable for formal proofs than the original semantics:
\begin{compactitem}
\item Launchbury’s global notion of “fresh variable” is hard to work with, as noted and fixed before by adding to the judgments an explicit list of variable names to avoid \cite{sestoft}. As the stack in our semantics already contains these names, this additional step is not required.
\item While proving Theorem \ref{thm_stackedcorrectness}, the environment $\rho$ does not have to be all-quantified in the inductive step. This simplified the proof a bit and avoids the pitfall that the original proof fell into.
\end{compactitem}
The similarity with the extended heaps in \cite{distributed} further supports the usefulness of the stacked semantics.

We had to spend slightly more pages on the properties of the original denotational semantics (Appendix~\ref{sec_denprops}) than of the update-based denotational semantics (Appendix~\ref{updsemanticsprops}). This is partly due to more details in the proofs in the former section, partly because $+$ behaves nicer than $\sqcup$ (e.g.\ it is defined everywhere). This is orthogonal to the usefulness of the stack-based natural semantics, which could be proven correct with regard to the updates-based denotational semantics as well.

Unless one has to stick with $\sqcup$, e.g. to stay compatible with previous work using this definition, little stands in the way of using the update-based denotational semantics to model the denotation of heaps.

\section{Future work}

Proving correctness is of course only half the battle: The adequacy of Launchbury’s semantics is not yet formally proven. The original paper itself outlines the steps of a proof, and some of these steps have since then been spelled out in greater detail \cite{functionspaces}, and the same authors are currently working on the equivalency of Launchbury’s original and modified natural semantics. We plan to build on these results to eventually have a machine-checked proof of the adequacy of Launchbury’s semantics.

We hope that by proving the correctness and adequacy in a theorem prover, we not “just” reinforce our theoretical foundations but also create a practical (for a theoretician’s understanding of practical) tool that can be used to experiment with the many various ways that this semantics can be extended and modified.

%\section*{Acknowledgments}

%I would like to thank Andreas Lochbihler and Denis Lohner for careful proof-reading and very constructive comments.

\bibliographystyle{jfp}
\bibliography{\jobname}

\appendix

\section{Appendix}
\subsection{Properties of the denotational semantics}
\label{updsemanticsprops}

A few technical lemmas about the denotational semantics are used in the proofs of correctness and adequacy; these are collected here.

These hold for both the standard denotational semantics and the resourced denotational semantics alike. In fact, in the formal development, they are stated and proven abstractly, using \emph{locales} \cite{locales} as a modularization tool. We state them only for the standard denotational semantics here.


\begin{lemma}[Applying the heap semantics]
\[
\label{lem_esem_this}
\label{lem_esem_other}
(\esem{\Gamma}\rho)\,x =
\begin{cases}
\dsem{e}{\esem{\Gamma}\rho}, & \text{if } (x\mapsto e)\in \Gamma \\
\rho\, x, & \text{if } x \notin \dom\Gamma.
\end{cases}
\]
\end{lemma}

\begin{proof}
by unrolling the fixed point once.
\end{proof}

In the case for variables in the correctness proof, we need the following alternative, iterative definition of the heap semantics:

\begin{lemma}[Iterative definition of the heap semantics]
\[
\esem{x \mapsto e, \Gamma}\rho =
\mu \rho'.\,  \big((\rho \upd{\dom\Gamma} {\esem{\Gamma}{\rho'}})[x \mapsto \dsem{e}{\esem{\Gamma}\rho'}]\big).
\label{lem_iter}
\]
\end{lemma}

A corresponding lemma can be found in Launchbury \shortcite{launchbury}, but without proof. As the proof involves some delicate fixed-point-juggling, we include it here in detail:

\begin{proof}
\newcommand{\domxG}{\dom{(x\mapsto e,\Gamma)}}
Let $L = (\lambda \rho'.\, \rho \upd{\domxG} \dsem{x\mapsto e, \Gamma}{\rho'})$ be the functorial of the fixed point on the left hand side, $R$~be the functorial on the right hand side.

By Lemma \ref{lem_esem_this}, we have
\begin{compactenum}[(1)]
\item $(\mu L)\, y = \dsem{e'}{\mu L}$ for $y\mapsto e'\in\dom\Gamma$,
\item $(\mu L)\, x = \dsem{e}{\mu L}$,
\item $(\mu L)\, y = \rho\, y$ for $y \notin \domxG$
\end{compactenum}
Similarly, by unrolling the fixed points, we have
\begin{compactenum}[(1)]
\item[(4)] $(\mu R)\, y = \dsem{e'}{\esem{\Gamma}{(\mu R)}}$ for $y \mapsto e'\in\dom\Gamma$,
\item[(5)] $(\mu R)\, x = \dsem{e}{\esem{\Gamma}{(\mu R)}}$,
\item[(6)] $(\mu R)\, y = \rho\, y$ for $y \notin \domxG$,
\end{compactenum}
and also for $\rho' \in \sEnv$ (in particular for $\rho' = (\mu L)$, $(\mu R)$), again using Lemma \ref{lem_esem_this},
\begin{compactenum}[(1)]
\item[(7)] $(\esem{\Gamma}{\rho'})\,y = \dsem{e}{\esem{\Gamma}{\rho'}}$ for $y \mapsto e' \in \dom\Gamma$,
\item[(8)] $(\esem{\Gamma}{\rho'})\,y = \rho'\, y$ for $y \notin \dom\Gamma$.
\end{compactenum}

\medskip
We obtain
\begin{compactenum}[(1)]
\item[(9)] $\esem{\Gamma}{(\mu R)} = (\mu R)$
\end{compactenum}
from comparing (4)--(6) with (7) and (8). We can also show
\begin{compactenum}[(1)]
\item[(10)] $\esem{\Gamma}{(\mu L)} = (\mu L)$,
\end{compactenum}
by antisymmetry and using that least fixed points are least pre-fixed points:
\begin{compactitem}[$\sqsubseteq$:]
\item[$\sqsubseteq$:] We need to show that $(\mu L) \upd{\dom\Gamma} \dsem{\Gamma}{(\mu L)} \sqsubseteq (\mu L)$, which follows from (1). 
\item[$\sqsupseteq$:] We need to show that $\esem{\Gamma}{(\mu L)} \upd{\domxG} \dsem{x\mapsto e, \Gamma}{\esem{\Gamma}{(\mu L)}} \sqsubseteq \esem{\Gamma}{(\mu L)}$. For $\dom\Gamma$, this follows from (7), so we show $\dsem{e}{\esem{\Gamma}{(\mu L)}} \sqsubseteq (\mu L)\, x = \dsem{e}{(\mu L)}$, which follows from the monotonicity of $\dsem{e}{\_}$ and case $\sqsubseteq$.
\end{compactitem}

To show the lemma, $(\mu L) = (\mu R)$, we use the antisymmetry of $\sqsubseteq$ and the leastness of least fixed points:
\begin{compactitem}[$\sqsubseteq$:]
\item[$\sqsubseteq$:] We need to show that $L\, (\mu R) = \mu R$, i.e.
\begin{compactitem}
\item $\rho\,y = (\mu R)\, y$ for $y \notin \domxG$, which follows from (6),
\item $\dsem{e'}{\mu R} = (\mu R)\, y$ for $y \mapsto e' \in \Gamma$, which follows from (4) and (9) and
\item $\dsem{e}{\mu R} = (\mu R)\, x$, which follows from (5) and (9).
\end{compactitem}
\item[$\sqsupseteq$:] Now we have to show that $R\ (\mu L) = (\mu L)$, i.e.
\begin{compactitem}
\item $\rho\,y = (\mu L)\, y$ for $y \notin \domxG$, which follows from (3),
\item $\dsem{e'}{\esem{\Gamma}{(\mu L)}} = (\mu L)\, y$ for $y \mapsto e' \in \Gamma$, which follows from (1) and (10), and
\item $\dsem{e}{\esem{\Gamma}{(\mu L)}} = (\mu L)\, x$, which follows from (2) and (10).
\end{compactitem}
\end{compactitem}
\end{proof}

We want to relate substitution of variables in terms with adding indirections on the heap. As a first step, we show that substitution does not matter if the environment agrees on these variables:

\begin{lemma}[Semantics of substitution]
\[
\label{lem_subst}
\dsem{e}{\rho (y \mapsto \rho~x)} = \dsem{ e[x/y]}{\rho}.
\]
\end{lemma}

\begin{proof}

We first show $\forall\rho.\, \rho\,x = \rho\,y \implies \esem{e}\rho = \esem{e[x/y]}\rho$ by induction on $e$, using parallel fixed-point induction in the case for \keyword{let}. This allows us to calculate
\begin{conteq}
\dsem{e}{\rho (y \mapsto \rho\,x)} \\
= \dsem{e[x/y]}{\rho (y \mapsto \rho\,x)} & as $\rho (y \mapsto \rho\,x)\,x=\rho (y \mapsto \rho\,x)\,y$ \\
=  \dsem{e[x/y]}{\rho} & as $y\notin \fv{e[x/y]}$.
\end{conteq}
\end{proof}

The final lemma required for the correctness proof shows that the denotation of set of bindings with only fresh variables can be merged with the heap it was defined over:

\begin{lemma}
\label{lem_esem-merge}
If $\dom \Gamma$ is fresh with regard to $\Delta$ and $\rho$, then
\[
\esem{\Gamma}{\esem{\Delta}\rho} = \esem{\Gamma, \Delta}\rho.
\]
\end{lemma}

\begin{proof}
%First note that
%\begin{align*}
%\esem{\Delta}\rho \preceq \esem{\Gamma}{\esem{\Delta}\rho}, \tag{$\ast$}
%\end{align*}
%as the variables bound in $\Gamma$ are fresh and existing bindings in $\esem{\Delta}\rho$ keep their semantics.

We use the antisymmetry of $\sqsubseteq$, and the leastness of least fixed points.
\begin{compactitem}[$\sqsubseteq$:]
\item[$\sqsubseteq$:] We need to show that $\esem{\Delta}\rho \upd{\dom\Gamma} \dsem\Gamma{\esem{\Delta,\Gamma}\rho} = \esem{\Delta,\Gamma}\rho$, which we verify pointwise.
\begin{compactitem}
\item For $x \in \dom\Gamma$, this follows directly from \myref{Lemma}{lem_esem_this}.
\item For $x\notin \dom\Gamma$, this follows as the variables bound in $\Gamma$ are fresh, so the bindings in $\esem{\Delta}\rho$ keep their semantics.
\end{compactitem}

\item[$\sqsupseteq$:] We need to show that $\rho \upd{\dom{(\Gamma,\Delta)}} \dsem{\Gamma, \Delta}{\esem{\Gamma}{\esem{\Delta}\rho}} = \esem{\Gamma}{\esem{\Delta}\rho}$.
\begin{compactitem}
\item For $x\in \dom\Gamma$, this follows from unrolling the fixed point on the right hand side once.
\item For $x\mapsto e \in \dom\Delta$ (and hence $x\notin \dom \Gamma$), we have
\begin{align*}
(\rho  \upd{\dom{(\Gamma,\Delta)}} \dsem{\Gamma, \Delta}{\esem{\Gamma}{\esem{\Delta}\rho}})\, x 
&= \dsem{e}{\esem{\Gamma}{\esem{\Delta}\rho}} \\
&= \dsem{e}{\esem{\Delta}\rho} \\
\aexpl{because $\dom\Gamma$ is fresh with regard to $e$} \\
&= (\esem\Delta\rho)\, x\\
\aexpl{by unrolling the fixed point} \\
&= (\dsem{\Gamma}{\esem\Delta\rho})\, x\\
\aexpl{because $x\notin \dom\Gamma$ and \myref{Lemma}{lem_esem_this}.}
\end{align*}
\item For $x\notin \dom \Gamma \cup \dom \Delta$, we have $\rho\, x$ on both sides.
\end{compactitem}
\end{compactitem}
\end{proof}


\end{document}
