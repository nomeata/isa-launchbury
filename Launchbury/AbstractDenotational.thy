theory AbstractDenotational
imports "Denotational-Common" CValue "HSemUpd"
begin


subsubsection {* The denotational semantics for expressions *}

(*
definition fun_restr :: "var set \<Rightarrow> (var \<Rightarrow> 'a::{pure_cpo,pcpo}) \<Rightarrow> (var \<Rightarrow> 'a)"
  where "fun_restr S f v = (if v \<in> S then f v else \<bottom>)"

abbreviation fun_restr_syn ("_|\<^bsub>_\<^esub>" [111,0]) where "f|\<^bsub>S\<^esub> \<equiv> fun_restr S f"

lemma fun_restr_eqvt[eqvt]: "\<pi> \<bullet> (f|\<^bsub>S\<^esub> v) = (\<pi> \<bullet> f)|\<^bsub>\<pi> \<bullet> S\<^esub> (\<pi> \<bullet> v)"
  unfolding fun_restr_def by auto

nominal_primrec
  ESem :: "exp \<Rightarrow> (var \<Rightarrow> Value) \<Rightarrow> Value" ("\<lbrakk>_\<rbrakk>\<^bsub>_\<^esub>"  [60,60] 60)
where
  "\<lbrakk> Lam [x]. e \<rbrakk>\<^bsub>\<rho>\<^esub> = Fn \<cdot> (\<Lambda> v. (\<lbrakk> e \<rbrakk>\<^bsub>\<rho>|\<^bsub>fv (Lam [x]. e)\<^esub>(x := v)\<^esub>))"
| "\<lbrakk> App e x \<rbrakk>\<^bsub>\<rho>\<^esub> = \<lbrakk> e \<rbrakk>\<^bsub>\<rho>\<^esub> \<down>Fn \<lbrakk> Var x \<rbrakk>\<^bsub>\<rho>\<^esub> "
| "\<lbrakk> Var x \<rbrakk>\<^bsub>\<rho>\<^esub> = \<rho> x"
| "\<lbrakk> Let as body \<rbrakk>\<^bsub>\<rho>\<^esub> = undefined"
(* | "set (bn as) \<sharp>* \<rho> \<Longrightarrow>
  \<lbrakk> Let as body \<rbrakk>\<^bsub>\<rho>\<^esub> = \<lbrakk>body\<rbrakk>\<^bsub>has_ESem.HSem ESem (asToHeap as) \<rho>\<^esub>" *)
proof-
txt {* The following proofs discharge technical obligations generated by the Nominal package. *}

case goal1 thus ?case
  unfolding eqvt_def ESem_graph_aux_def by simp
next
case (goal3 P x) 
  show ?case
  proof(cases x)
  case (Pair e \<rho>)
    show ?thesis
      using Pair goal3
      by (metis (full_types) exp_assn.exhaust(1))
  qed
next

case (goal4 x e \<rho> x' e' \<rho>')
  from goal4(5)
  have "\<rho> = \<rho>'" by simp

  from goal4(5)
  have "(x = x' \<and> e = e' \<or> x \<noteq> x' \<and> e = (x \<leftrightarrow> x') \<bullet> e' \<and> atom x \<sharp> e')"
    by (simp only: Pair_eq exp_assn.eq_iff(4) Abs1_eq_iff)
  thus ?case
  proof (elim conjE disjE)
    assume "x \<noteq> x'"
    assume "e = (x \<leftrightarrow> x') \<bullet> e'"
    hence "(x' \<leftrightarrow> x) \<bullet> e = e'" by simp
    assume "atom x \<sharp> e'" 
    hence "x \<notin> fv e'" unfolding fv_not_fresh.

    { fix xa
      have "ESem_sumC (e, ((fun_restr (fv (Lam [x]. e)) \<rho>)(x := xa))) = (x' \<leftrightarrow> x) \<bullet> (ESem_sumC (e, ((fun_restr (fv (Lam [x]. e)) \<rho>)(x := xa))))" by (simp add: permute_pure)
      also have "\<dots> = ESem_sumC ((x' \<leftrightarrow> x) \<bullet> ((e, (fun_restr (fv (Lam [x]. e)) \<rho>)(x := xa))))"
        using goal4(1) by (metis eqvt_at_def)
      also have "\<dots> = ESem_sumC ((x' \<leftrightarrow> x) \<bullet> e, (fun_restr (fv ((x' \<leftrightarrow> x) \<bullet> e) - {x'}) ((x' \<leftrightarrow> x) \<bullet> \<rho>))(x' := xa))"
        by simp
      also note `_ = e'`
      also have "fun_restr (fv e' - {x'}) ((x' \<leftrightarrow> x) \<bullet> \<rho>) = fun_restr (fv e' - {x'}) \<rho>'"
        apply rule
        apply (auto simp add: fun_restr_def `\<rho> = \<rho>'`)
        by (metis eqvt_bound eqvt_lambda flip_at_base_simps(3) permute_flip_cancel2 permute_pure  `x \<notin> fv e'`)
      also have "fv e' - {x'} = fv (Lam [x']. e')" by simp
      finally
      have "ESem_sumC (e, ((fun_restr (fv (Lam [x]. e)) \<rho>)(x := xa))) = ESem_sumC (e', (fun_restr (fv (Lam [x']. e')) \<rho>')(x' := xa))".
    }
    thus ?thesis by simp
  qed (simp add: `\<rho> = \<rho>'`)
next
thm Abs_eq_iff
thm Abs_eq_iff[unfolded alpha_lst.simps]
*)

locale semantic_domain =
  fixes Fn :: "('Value \<rightarrow> 'Value) \<Rightarrow> ('Value::{pcpo,pure_cpo,Nonempty_Meet_cpo})"
  fixes Fn_project :: "'Value \<Rightarrow> ('Value \<Rightarrow> 'Value)"
  fixes tick :: "'Value \<Rightarrow> 'Value"
begin

nominal_primrec
  AESem :: "exp \<Rightarrow> (var f\<rightharpoonup> 'Value) \<Rightarrow> 'Value" ("\<lbrakk>_\<rbrakk>\<^bsub>_\<^esub>"  [60,60] 60)
where
  (* Restrict \<rho> to avoid having to demand atom x \<sharp> \<rho> *)
 "\<lbrakk> Lam [x]. e \<rbrakk>\<^bsub>\<rho>\<^esub>  = tick (Fn (\<Lambda> v. \<lbrakk>e\<rbrakk>\<^bsub>(\<rho> f|`(fv (Lam [x]. e)))(x f\<mapsto> v)\<^esub>))"
  (* Do not use \<N>\<lbrakk> Var x \<rbrakk>\<^bsub>\<rho>\<^esub>  in the rule for App; it costs an additional
     resource and makes the adequacy proof difficult. *)
| "\<lbrakk> App e x \<rbrakk>\<^bsub>\<rho>\<^esub>    = tick (Fn_project  (\<lbrakk>e\<rbrakk>\<^bsub>\<rho>\<^esub>) (\<rho> f!\<^sub>\<bottom> x))"
| "\<lbrakk> Var x \<rbrakk>\<^bsub>\<rho>\<^esub>      = tick (\<rho> f!\<^sub>\<bottom> x)"
| "set (bn as) \<sharp>* \<rho> \<Longrightarrow>
  \<lbrakk> Let as body \<rbrakk>\<^bsub>\<rho>\<^esub> = tick (\<lbrakk>body\<rbrakk>\<^bsub>has_ESem.UHSem AESem (asToHeap as) \<rho>\<^esub>)"
proof-
txt {* The following proofs discharge technical obligations generated by the Nominal package. *}

case goal1 thus ?case
  unfolding eqvt_def AESem_graph_aux_def by simp
next
case (goal3 P x)
  show ?case
  proof(cases x)
  case (Pair e \<rho>)
    show ?thesis 
      using Pair goal3
      by (metis (no_types) exp_assn.strong_exhaust(1))
  qed
next

case (goal4 x e \<rho> x' e' \<rho>')
  from goal4(5)
  have "\<rho> = \<rho>'" by simp

  from goal4(5)
  have "(x = x' \<and> e = e' \<or> x \<noteq> x' \<and> e = (x \<leftrightarrow> x') \<bullet> e' \<and> atom x \<sharp> e')"
    by (simp only: Pair_eq exp_assn.eq_iff(4) Abs1_eq_iff)
  thus ?case
  proof (elim conjE disjE)
    assume "x \<noteq> x'"
    assume "e = (x \<leftrightarrow> x') \<bullet> e'"
    hence "(x' \<leftrightarrow> x) \<bullet> e = e'" by simp
    assume "atom x \<sharp> e'" 
    hence "x \<notin> fv e'" unfolding fv_not_fresh.

    { fix xa
      have "AESem_sumC (e, (\<rho> f|` fv (Lam [x]. e))(x f\<mapsto> xa)) = (x' \<leftrightarrow> x) \<bullet> AESem_sumC (e, (\<rho> f|` fv (Lam [x]. e))(x f\<mapsto> xa))" by (simp add: permute_pure)
      also have "\<dots> = AESem_sumC ((x' \<leftrightarrow> x) \<bullet> (e, (\<rho> f|` fv (Lam [x]. e))(x f\<mapsto> xa)))"
        using goal4(1) by (metis eqvt_at_def)
      also have "\<dots> = AESem_sumC ((x' \<leftrightarrow> x) \<bullet> e, (((x' \<leftrightarrow> x) \<bullet> \<rho>) f|` (fv ((x' \<leftrightarrow> x) \<bullet> e) - {x'}))(x' f\<mapsto> xa))"
        by simp
      also note `_ = e'`
      also have "((x' \<leftrightarrow> x) \<bullet> \<rho>) f|` (fv e' - {x'}) = \<rho> f|` (fv e' - {x'})"
        by (rule fmap_restr_perm) (auto simp add: `x \<notin> fv e'`)
      also have "fv e' - {x'} = fv (Lam [x']. e')" by simp
      finally
      have "AESem_sumC (e, ((fmap_restr (fv (Lam [x]. e)) \<rho>)(x f\<mapsto> xa))) = AESem_sumC (e', (fmap_restr (fv (Lam [x']. e')) \<rho>')(x' f\<mapsto> xa))"
        unfolding `\<rho> = \<rho>'`.
    }
    thus ?thesis by simp
  qed (simp add: `\<rho> = \<rho>'`)
next

case (goal13 as \<rho> body as' \<rho>' body')
  assume eqvt1: "\<And> e x. e \<in> snd ` set (asToHeap as) \<Longrightarrow> eqvt_at AESem_sumC (e, x)"
    and eqvt2:"eqvt_at AESem_sumC (body, has_ESem.UHSem (\<lambda>x0 x1. AESem_sumC (x0, x1)) (asToHeap as) \<rho>)"
    and eqvt3:"\<And>e x. e \<in> snd ` set (asToHeap as') \<Longrightarrow> eqvt_at AESem_sumC (e, x)"
    and eqvt4:"eqvt_at AESem_sumC (body', has_ESem.UHSem (\<lambda>x0 x1. AESem_sumC (x0, x1)) (asToHeap as') \<rho>')"

  assume fresh1: "set (bn as) \<sharp>* \<rho>" and fresh2: "set (bn as') \<sharp>* \<rho>'"
  assume "(Terms.Let as body, \<rho>) =  (Terms.Let as' body', \<rho>')"
  hence tmp: "[bn as]lst. (body, as) = [bn as']lst. (body', as')" and rho:"\<rho>' = \<rho>" by auto

  have "AESem_sumC (body, has_ESem.UHSem (\<lambda>x0 x1. AESem_sumC (x0, x1)) (asToHeap as) \<rho>) =
        AESem_sumC (body', has_ESem.UHSem (\<lambda>x0 x1. AESem_sumC (x0, x1)) (asToHeap as') \<rho>)"
  proof (rule Abs_lst_fcb[where ba = bn and f = "(\<lambda> as (body, as'). AESem_sumC (body, has_ESem.UHSem (\<lambda>x0 x1. AESem_sumC (x0, x1)) (asToHeap as) \<rho>))", OF tmp pure_fresh pure_fresh, simplified])
    fix p
    assume "p \<bullet> body = body' \<and> p \<bullet> as = as'" hence "p \<bullet> body = body'" and "p \<bullet> as = as'" by auto
    assume "supp p \<subseteq> set (bn as) \<union> set (bn as')"
    have "p \<bullet> \<rho> = \<rho>"
      apply (rule perm_supp_eq)
      using fresh1 fresh2
      apply (simp add: fresh_star_def)
      by (metis (full_types) Un_iff `supp p \<subseteq> set (bn as) \<union> set (bn as')` rho set_mp)

    have "(p \<bullet> AESem_sumC) (body', has_ESem.UHSem (\<lambda>x xa. (p \<bullet> AESem_sumC) (x, xa)) (asToHeap as') (p \<bullet> \<rho>)) =
          (p \<bullet> AESem_sumC) (body', has_ESem.UHSem (\<lambda>x xa. AESem_sumC (x, xa)) (asToHeap as') (p \<bullet> \<rho>))"
      apply (rule arg_cong[OF UHSem_cong[OF _ refl refl]])
      apply (subst eqvt_at_apply[OF eqvt3], assumption)
      by rule
    also have "\<dots> = (p \<bullet> AESem_sumC) (body', has_ESem.UHSem (\<lambda>x xa. AESem_sumC (x, xa)) (asToHeap as') \<rho>')"
      by (simp add: `p \<bullet> \<rho> = \<rho>` `\<rho>' = \<rho>`)
    also have "\<dots> = AESem_sumC (body', has_ESem.UHSem (\<lambda>x xa. AESem_sumC (x, xa)) (asToHeap as') \<rho>')"
      by (rule eqvt_at_apply[OF eqvt4])
    also have "\<dots> = AESem_sumC (body', has_ESem.UHSem (\<lambda>x xa. AESem_sumC (x, xa)) (asToHeap as') \<rho>)"
      by (simp add: `\<rho>' = \<rho>`)
    finally
    show "(p \<bullet> AESem_sumC) (body', has_ESem.UHSem (\<lambda>x xa. (p \<bullet> AESem_sumC) (x, xa)) (asToHeap as') (p \<bullet> \<rho>)) =
               AESem_sumC (body', has_ESem.UHSem (\<lambda>x0 x1. AESem_sumC (x0, x1)) (asToHeap as') \<rho>)".
  qed
  thus ?case using `\<rho>' = \<rho>`  by simp
qed auto

termination (in semantic_domain) (eqvt) by lexicographic_order

end

sublocale semantic_domain < has_ESem AESem.

context semantic_domain begin

subsubsection {* Equivariance of the semantics *}

lemma permute_ESem: "\<pi> \<bullet> AESem = AESem"
  by (perm_simp, rule)

lemmas HSem_eqvt' = UHSem_eqvt[of _ AESem, unfolded permute_ESem]

lemmas HSem_fresh[simp] = eqvt_fresh_cong2[of UHSem, OF HSem_eqvt']
 and   HSem_fresh_star[simp] = eqvt_fresh_star_cong2[of UHSem, OF HSem_eqvt']
 and   asToHeap_fresh[simp] = eqvt_fresh_cong1[of asToHeap, OF asToHeap.eqvt]
 and   asToHeap_fresh_star[simp] = eqvt_fresh_star_cong1[of asToHeap, OF asToHeap.eqvt]
 and   fresh_fmap_upd[simp] = eqvt_fresh_cong3[of fmap_upd, OF fmap_upd_eqvt]

end

end

